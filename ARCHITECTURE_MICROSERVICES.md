# Дальнейшие шаги для модульного монолита и мягкого выхода в микросервисы

Ниже — конкретные доработки, которые повышают гибкость продукта, готовят его к безболезненному выделению модулей в микросервисы и поддерживают чистоту DDD.

## 1. Упаковка контекстов как отдельные модули
- **Отдельные go-модули/пакеты для bounded context**: каждый контекст собирается и тестируется отдельно (например, `internal/modules/users` как независимый модуль). Это облегчает выделение в сервис без переписывания импортов.
- **Соглашения об экспортируемых API**: наружу отдавать только application-порты (команды/квери), скрывая domain и инфраструктуру. Добавить фасады `app.Service` на контекст.
- **Стабильные DTO/контракты**: в application-слое зафиксировать DTO и запретить leaking внутренних структур.

## 2. Доменные события и интеграционный слой
- **Доменные события как первичный канал связи контекстов**: описать их в domain и публиковать через порт `DomainEventPublisher` с outbox-паттерном в инфраструктуре.
- **Анти-коррапшен слой между контекстами**: когда один контекст использует данные другого, применять ACL, переводя внешние DTO в свои value objects.
- **Идемпотентность**: слушатели событий должны быть идемпотентны (хранить обработанные event-id, дедуплицировать).

## 3. Контракты, версионирование и совместимость
- **Версионирование API и событий**: фиксировать версии команд/квери и событий, поддерживать N-1 совместимость, описывать схемы (OpenAPI/AsyncAPI/Protobuf schema registry).
- **Контрактные тесты**: consumer/provider-тесты для HTTP/gRPC и событий. В контракте фиксировать pre/post-conditions и ошибки.
- **Политика изменений схем БД**: миграции через платформенный слой; запрет на прямые SQL в модулях.

## 4. Транзакционные границы и консистентность
- **Явные границы транзакций в application**: use-case работает через `UnitOfWork`; никакой скрытой работы с БД/кэшем в domain.
- **Саги/оркестраторы**: для кросс-контекстных бизнес-процессов описывать долгоживущие транзакции (оркестратор в application или процесс-менеджер в отдельном модуле).
- **Outbox + message relay**: запись событий в одной транзакции с агрегацией, фоновые воркеры отвечают за доставку.

## 5. Обсервабельность и эксплуатация
- **Единые метрики/трейсы/логи**: добавить middleware с трассировкой (trace-id) и метриками per use-case. Договориться о форматах логов, логировать входные/выходные DTO без чувствительных данных.
- **Feature flags и конфигурация**: все новые возможности включать через флаги, конфигурацию инжектить в композиционном корне.
- **Chaos/latency тесты**: предусмотреть fault injection на уровне транспортных адаптеров, чтобы проверять устойчивость до выноса в сервис.

## 6. Тестовая стратегия для модульного монолита
- **Юнит-тесты на инварианты**: покрыть агрегаты и value objects.
- **Application-тесты с моками портов**: проверять use-case и транзакционные границы.
- **Контрактные тесты**: фиксируют вход/выход адаптеров; должны остаться неизменными при выносе в микросервис.
- **Интеграционные тесты «сквозь»**: HTTP/gRPC + БД + очередь, ближе всего к будущему сервису.

## 7. Пошаговый план выделения контекста в микросервис
1. **Заморозить внешний контракт контекста** (команды/квери + события) и задокументировать его.
2. **Ввести ACL** для входящих вызовов из других контекстов, чтобы убрать прямые зависимости от их типов/таблиц.
3. **Добавить outbox/инбокс** и идемпотентных слушателей, убедиться, что side effects отделены от доменной логики.
4. **Собрать контекст отдельным бинарем** (но в монорепе), подключив только нужные адаптеры (БД, очередь, HTTP/gRPC).
5. **Вынести в отдельный деплой**: поднять миграции, настроить транспорт (gRPC/HTTP/события) и маршрутизацию. При этом все остальные контексты общаются только через зафиксированные контракты.
6. **Постепенно удалить встроенные вызовы**: перевести межконтекстное взаимодействие на сеть/шину, удалить внутренние импорты.

## 8. Разделение общих зависимостей
- **Shared kernel — только проверенные value objects/стандарты** (ID, Money, Time). Никаких бизнес-правил разных контекстов внутри.
- **Инфраструктурные кросс-контекстные пакеты**: логгер, http/middleware, клиенты очередей — в `internal/platform`, без зависимостей на конкретный контекст.

## 9. Безопасность и данные
- **Чёткий boundary для PII/секретов**: шифрование, маскирование в логах, запрет прямых SQL с секретными полями вне инфраструктуры.
- **Многотенантность/изоляция**: если планируется, описать tenant-aware value objects и маршрутизацию данных заранее.
- **Политика данных при выделении**: заранее определить, какие таблицы идут в отдельную БД сервиса, какие остаются разделёнными (shared read models), и как временно поддерживать двустороннюю синхронизацию.

## 10. Устойчивость и взаимодействия между сервисами
- **Контракты SLA/SLO**: для каждого выделяемого контекста фиксировать SLO по латентности/доступности; выставить метрики и алерты.
- **Защита от каскадных сбоев**: таймауты, ретраи с джиттером, circuit breaker, rate limiting и quota per consumer.
- **Идемпотентные команды**: все внешние write-команды должны быть идемпотентны (ключ идемпотентности или бизнес-ключ), чтобы упрощать ретраи.
- **Bulkhead и backpressure**: разделить пулы/очереди по типам нагрузок, отклонять запросы раньше, чем сервис истощит ресурсы.

## 11. Данные и миграции при разделении
- **Шаговая миграция БД**: сначала ввести view/read-модель, которая питается из старой БД, затем разнести записи в новую БД сервиса через фоновый мигратор или CDC; поддерживать двустороннюю запись до переключения клиентов.
- **Стратегия «expand/contract»**: при изменении схемы и контрактов использовать совместимые добавления, затем удалять старые поля после переключения всех потребителей.
- **Согласование ключей и идентификаторов**: договориться о формате ID между сервисами (ULID/UUID), избегать автоинкремента, чтобы упростить миграции.
- **Политика доступа к данным из других контекстов**: только через публичные контракты или материализованные read-модели; прямые чтения из чужой БД запрещены.

## 12. Управление зависимостями и эволюцией
- **Release-календарь контекстов**: фиксировать версии и дату деплоя по каждому контексту, запрещать breaking change без согласованного окна.
- **Каталог контрактов**: единое место (docs + schema registry) со всеми HTTP/gRPC/AsyncAPI контрактами и их статусами (beta/stable/deprecated).
- **Governance решений**: добавить lightweight ADR (Architecture Decision Records) на ключевые решения по интеграциям, данным, безопасности; хранить в репозитории рядом с кодом.
- **Template для новых сервисов**: подготовить boilerplate (метрики, healthcheck, миграции, observability, тестовые пайплайны), чтобы выделение очередного контекста было механическим.

Следуя этим шагам, можно эволюционировать модульный монолит в микросервисы без массовых переписываний, сохраняя чистую доменную модель и стабильные контракты.
